/**
 * This program outputs a random value for electing a leader 
 * and a punctured secret value based on the secret value obtained as an input.
 * The punctured secret value is generated by convolutional encoding.
*/

#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <sstream>
#include <string>
#include <vector>
#include <ctime>
#include "prvhash_core.h"
#include "cmdline.h"
#include "viterbi.h"

using namespace std;

const uint64_t defaultSeed = 0x93064E905C127FE5;
const uint64_t defaultHash = 0xA4BDE5C4A05E6256;
const uint64_t defaultlcg = 0;
int keySize = 0;

uint64_t stringToDecimal(std::string);
void puncturing(uint64_t);
std::string decimalToBinary(uint64_t);
std::vector<string> splitBinaryVector(std::string&, int);
std::string bitFlip(const std::string&);

int main(int argc, char* argv[]){
    uint64_t seed = defaultSeed; /* secret */
    uint64_t lcg = defaultlcg;
    uint64_t hash = defaultHash; /* key */
    uint64_t v = 0;
    uint64_t i;
    
    //std::string in_seed;
    //std::string in_hash;

    /* for analyzing command line arguments */
    cmdline::parser p;
    p.add<string>("secret", 's', "secret value", false);
    p.add<string>("key", 'k', "key value", false);
    p.add("help", 0, "print usage");

    if(!p.parse(argc, argv) || p.exist("help")) {
        std::cout << p.error_full() << p.usage();
        return 0;
    }

    if (p.exist("secret")) {
        //in_seed = argv[2]; //p.get<std::string>("secret"); 
        seed = stringToDecimal(argv[2]);
    }

    if(p.exist("key")) {
        /* hash = stringToDecimal(p.get<std::string>("key")); */
        //in_hash = argv[4];
        hash = stringToDecimal(argv[4]);
    }

    cout << "secret: " << seed << endl;

    // generating a random value by prf
    for ( i = 0; i < ( 1ULL << 28); i++) {
        v = prvhash_core64( &seed, &lcg, &hash);
    }

    cout << "result: " << v << endl; 

    puncturing(v);


}


/* puncturing a random value */
void puncturing(uint64_t rvalue) {
    vector<string> splvec;
    vector<int> polynomials;
    int constraint = 3;
    ostringstream oss;
    string rval_str;

    polynomials.push_back(6);
    polynomials.push_back(5);
    ViterbiCodec codec(constraint, polynomials);

    rval_str = decimalToBinary(rvalue); // converted from unit64_t to binary vector
    keySize = rval_str.size();

    std::cout << "size: " << keySize << " key: " << rval_str << std::endl; // for debug

    splvec = splitBinaryVector(rval_str, 7);

    // print for debug
    for (auto itr = splvec.begin(); itr != splvec.end(); ++itr) {
        cout << "vec: " << *itr << endl;
        cout << " enc: " << codec.Encode(*itr); 
        cout << " punc: " << bitFlip(codec.Encode(*itr)) << endl;
    }

    //std::cout << "punctured: " << codec.Encode(rval_str) << std::endl;


}

/* bit flips */
string bitFlip(const string& inbits){
    string bits = inbits;
    srand( time(NULL) );
    int insize = bits.size();
    int pos, offset;
    pos = rand() % insize;
    offset = pos + 4;

    if (bits[pos] == '0'){
        bits[pos] = '1';
    } else {
        bits[pos] = '0';
    }

    if (bits[(pos + offset) % insize] == '0') {
        bits[(pos + offset) % insize] = '1';
    } else {
        bits[(pos + offset) % insize] = '0';
    }

    return bits;

}

/* converting from string to unit64_t */
uint64_t stringToDecimal(std::string sarg) {
    unsigned int value;
    uint64_t ret;
    istringstream iss(sarg);

    iss >> hex >> value;

/*    value << std::hex << iss; */

    cout << sarg << endl;

    ret = static_cast<uint64_t>(value); 

    return ret;
}

/* converting from hex string to binary vector */
std::vector<char> hexToBinary (std::string inHex){
    char tmp[256], out[256];
    long b = strtol(tmp, NULL, 16);
    int i = 0;
    std::vector<char> v;

    while(b) {
        out[i++] = b%2 + '0';
        b /= 2;
    }

    while(i--) {
        v.push_back(out[i]);
    }

    return v;
}

/* split vector in to a small vector of a certain length */
vector<string> splitBinaryVector (string& vec, int num){

    vector<string> result;
 
    for (size_t i = 0; i < vec.size(); i += num) {
        result.push_back(vec.substr(i, num));
    }
 
    //padding with 0
    if (result[result.size() - 1].size() < num) {
        for(int remaining = num - result[result.size() - 1].size(); remaining < 0; remaining--) {
            result[result.size() - 1] += '0';
        }

    }

    return result;

}

string decimalToBinary(uint64_t n) {
 
    string result;
    while (n != 0){
        result += n % 2 == 0 ? '0' : '1' ;
        n /= 2;
    }
    reverse(result.begin(), result.end());
    return result;
}


