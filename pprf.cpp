/**
 * This program outputs a random value for electing a leader 
 * and a punctured secret value based on the secret value obtained as an input.
 * The punctured secret value is generated by convolutional encoding.
*/

#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <sstream>
#include <string>
#include <vector>
#include <ctime>
#include "prvhash_core.h"
#include "cmdline.h"
#include "viterbi.h"

using namespace std;

class PPRF {
public:
    uint64_t hexToDecimal(string);
    vector<char> hexToBinary(string);
    uint64_t prf(uint64_t *, uint64_t *, uint64_t *);
    string puncturing(uint64_t);
    string decimalToBinary(uint64_t);
    string binaryToHex(string);
    vector<string> splitBinaryVector(string&, int);
    string bitFlip(const string&);
private:
    int keySize = 0;
};



/* pseudo-random function */
uint64_t PPRF::prf(uint64_t *seed, uint64_t *lcg, uint64_t *hash){        
    uint64_t ret = 0;
    uint64_t i;
    // generating a random value by prf
    for ( i = 0; i < ( 1ULL << 28); i++) {
        ret = prvhash_core64(seed, lcg, hash);
    }

    return ret;

}

/* puncturing a random value */
string PPRF::puncturing(uint64_t rvalue) {
    vector<string> splvec;
    vector<int> polynomials;
    int constraint = 3;
    ostringstream oss;
    string rval_str;
    string enc;
    string punc;
    string result;

    polynomials.push_back(6);
    polynomials.push_back(5);
    ViterbiCodec codec(constraint, polynomials);

    rval_str = decimalToBinary(rvalue); // converted from unit64_t to binary vector
    keySize = rval_str.size();

    std::cout << "size: " << keySize << " key: " << rval_str << std::endl; // for debug

    splvec = splitBinaryVector(rval_str, 7);

    // print for debug
    for (auto itr = splvec.begin(); itr != splvec.end(); ++itr) {
        enc = codec.Encode(*itr);
        punc = bitFlip(enc); // encoding and bit flipping
        result += punc;
        cout << "vec: " << *itr << endl;
        cout << " enc: " << enc; 
        //cout << " hex: " << binaryToHex(codec.Encode(*itr));
        cout << " punc: " << punc << endl;
    }

    //std::cout << "punctured: " << codec.Encode(rval_str) << std::endl;

    return result;

}

/* bit flips */
string PPRF::bitFlip(const string& inbits){
    string bits = inbits;
    srand( time(NULL) );
    int insize = bits.size();
    int pos, offset;
    pos = rand() % insize;
    offset = (rand() % insize/3) * 2;

    if (bits[pos] == '0'){
        bits[pos] = '1';
    } else {
        bits[pos] = '0';
    }

    if (bits[(pos + offset) % insize] == '0') {
        bits[(pos + offset) % insize] = '1';
    } else {
        bits[(pos + offset) % insize] = '0';
    }

    return bits;

}

/* converting from string to unit64_t */
uint64_t PPRF::hexToDecimal(std::string sarg) {
    unsigned int value;
    uint64_t ret;
    istringstream iss(sarg);

    iss >> hex >> value;

/*    value << std::hex << iss; */

    cout << sarg << endl;

    ret = static_cast<uint64_t>(value); 

    return ret;
}

/* converting from hex string to binary vector */
std::vector<char> PPRF::hexToBinary (std::string inHex){
    char tmp[256], out[256];
    long b = strtol(tmp, NULL, 16);
    int i = 0;
    std::vector<char> v;

    while(b) {
        out[i++] = b%2 + '0';
        b /= 2;
    }

    while(i--) {
        v.push_back(out[i]);
    }

    return v;
}

/* converting from binary vector to hex string */
std::string PPRF::binaryToHex (std::string inBin) {
    uint64_t num;
    stringstream ss;
    istringstream iss = istringstream(inBin);

    iss >> num;
    
    ss << std::hex << num;

    return ss.str();

}

/* split vector in to a small vector of a certain length */
vector<string> PPRF::splitBinaryVector (string& vec, int num){

    vector<string> result;
 
    for (size_t i = 0; i < vec.size(); i += num) {
        result.push_back(vec.substr(i, num));
    }
 
    //padding with 0
    if (result[result.size() - 1].size() < num) {
        for(int remaining = num - result[result.size() - 1].size(); remaining < 0; remaining--) {
            result[result.size() - 1] += '0';
        }

    }

    return result;

}

string PPRF::decimalToBinary(uint64_t n) {
 
    string result;
    while (n != 0){
        result += n % 2 == 0 ? '0' : '1' ;
        n /= 2;
    }
    reverse(result.begin(), result.end());
    return result;
}

/* Test code for using the class PPRF */
int main(int argc, char* argv[]){
    const uint64_t defaultSeed = 0x93064E905C127FE5;
    const uint64_t defaultHash = 0xA4BDE5C4A05E6256;
    const uint64_t defaultlcg = 0;
    int keySize = 0;

    uint64_t seed = defaultSeed; /* secret */
    uint64_t lcg = defaultlcg;
    uint64_t hash = defaultHash; /* key */
    uint64_t v = 0;
    string result;

    PPRF pr = PPRF();
    
    //std::string in_seed;
    //std::string in_hash;

    /* for analyzing command line arguments */
    cmdline::parser cla;
    cla.add<string>("secret", 's', "secret value", false);
    cla.add<string>("key", 'k', "key value", false);
    cla.add("help", 0, "print usage");

    if(!cla.parse(argc, argv) || cla.exist("help")) {
        std::cout << cla.error_full() << cla.usage();
        return 0;
    }

    if (cla.exist("secret")) {
        //in_seed = argv[2]; //p.get<std::string>("secret"); 
        seed = pr.hexToDecimal(argv[2]);
    }

    if(cla.exist("key")) {
        /* hash = hexToDecimal(p.get<std::string>("key")); */
        //in_hash = argv[4];
        hash = pr.hexToDecimal(argv[4]);
    }

    

    cout << "secret: " << seed << endl;

    v = pr.prf(&seed, &lcg, &hash);

    cout << "key (decimal): " << v << endl; 

    result = pr.puncturing(v);

    cout << "punctured key: " << result << endl;


}

